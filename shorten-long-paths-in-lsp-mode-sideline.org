#+LATEX_HEADER: \usepackage[margin=0.5in]{geometry}
#+OPTIONS: toc:nil

#+HUGO_BASE_DIR: /home/shane/dump/home/shane/notes/ws/blog/blog
#+HUGO_SECTION: ./posts

#+TITLE: Shorten long paths in lsp-mode sideline
#+DATE: <2020-11-12>
#+AUTHOR: Shane Mulligan
#+KEYWORDS: emacs lsp

** Premise
As I was reading some haskell, I was bothered
by the long =lsp-ui-sideline= strings, which
were encroaching upon my code.

** Demo: Before and after
#+BEGIN_EXPORT html
<a title="asciinema recording" href="https://asciinema.org/a/F1tsUAXHlpwivutZLA4Z7DNVe" target="_blank"><img alt="asciinema recording" src="https://asciinema.org/a/F1tsUAXHlpwivutZLA4Z7DNVe.svg" /></a>
#+END_EXPORT

** LSP string format
There is a file in =lsp-mode=, =lsp-
protocol.el= which contains code to /generate/
functions for reading and writing to lsp
formatted strings.

https://github.com/emacs-lsp/lsp-mode/blob/master/lsp-protocol.el

** Code
*** Before
#+BEGIN_SRC emacs-lisp -n :async :results verbatim code
  (defun lsp-ui-sideline--extract-info (contents)
    "Extract the line to print from CONTENTS.
  CONTENTS can be differents type of values:
  MarkedString | MarkedString[] | MarkupContent (as defined in the LSP).
  We prioritize string with a language (which is probably a type or a
  function signature)."
    (when contents
      (cond
       ((lsp-marked-string? contents) contents)
       ((vectorp contents)
        (seq-find (lambda (it) (and (lsp-marked-string? it)
                                    (lsp-get-renderer (lsp:marked-string-language it))))
                  contents))
       ((lsp-markup-content? contents) contents))))
#+END_SRC

*** After
#+BEGIN_SRC emacs-lisp -n :async :results verbatim code
  (defun lsp-ui-sideline--extract-info (contents)
    "Extract the line to print from CONTENTS.
  CONTENTS can be differents type of values:
  MarkedString | MarkedString[] | MarkupContent (as defined in the LSP).
  We prioritize string with a language (which is probably a type or a
  function signature)."
    (when contents
      (cond
       ((lsp-marked-string? contents)
        (lsp:set-marked-string-value contents (mnm (lsp:marked-string-value contents)))
        contents)
       ((vectorp contents)
        (seq-find (lambda (it) (and (lsp-marked-string? it)
                                    (lsp-get-renderer (lsp:marked-string-language it))))
                  contents))
       ((lsp-markup-content? contents)
        ;; This successfully minimises haskell sideline strings
        (lsp:set-markup-content-value contents (mnm (lsp:markup-content-value contents)))
        contents))))
#+END_SRC